(* generated by Ott 0.21.2 from: ott/Syntax.ott ott/Common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import ott_list_core.


Definition index := nat.
Lemma eq_index: forall (x y : index), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_index : ott_coq_equality.
Require Export PArith.
Require Import ZArith.
Require Export Structures.Equalities.

Require Export List.

Require Import Syntax.
Require Export Zinf.



Definition n := Zinf.
Lemma eq_n: forall (x y : n), {x = y} + {x <> y}.
Proof.
repeat decide equality.
Defined.
Hint Resolve eq_n : ott_coq_equality.

Definition le_var : Set := positive.

Inductive lockenv : Set :=  (*r Lock Environment expression *)
 | le_Empty : lockenv
 | le_Var (X:le_var)
 | le_Append (D:lockenv) (r:lockset) (n5:n)
 | le_Add (D:lockenv) (D':lockenv)
 | le_Sub (D:lockenv) (D':lockenv).

Inductive ineq : Set :=  (*r Single Constraint *)
 | c_LockSet (r:lockset) (r':lockset)
 | c_LockEnv (D:lockenv) (D':lockenv).

Inductive type_formula : Set := 
.

(*
Module MiniDecIneq <: MiniDecidableType.
    Definition t := ineq.
    Lemma eq_dec: forall (x y : t), {x=y}+{x<>y}.
    Proof.
        repeat decide equality.
    Qed.
End MiniDecIneq.

Module UDT_Ineq := Make_UDT MiniDecIneq.

Module Export IneqSet := MSetWeakList.Make UDT_Ineq.
Module Export IneqSetProp := WPropertiesOn UDT_Ineq IneqSet.
*)

(*
Module IneqSet.
    Definition t := list ineq.
    Definition empty : t := nil.
    Definition singleton x : t := x :: nil.
    Definition union a b : t := a ++ b.
    Definition elements x : t := x.
    Definition add a x : t := a :: x.
    Definition fold {B} f x b := @fold_right B ineq f b x.
End IneqSet.
*)




Inductive effect : Set :=  (*r Effect *)
 | EffectIntro (D_1:lockenv) (D_2:lockenv).

Inductive annotatedtype : Set :=  (*r Annotated Type *)
 | at_Bool : annotatedtype
 | at_Thread : annotatedtype
 | at_Lock (r:lockset)
 | at_Arrow (AT_1:annotatedtype) (phi:effect) (AT_2:annotatedtype).

Definition constraints : Set := list ineq.

Inductive scheme : Type :=  (*r Typescheme *)
 | sc_Quant (_:list ls_var) (_:list le_var) (C:constraints) (AT:annotatedtype).

Inductive context : Type := 
 | G_Empty : context (*r Empty context *)
 | G_Extend (G:context) (x:variable) (SC:scheme) (*r Extend (G:context) with (x:variable) : (SC:scheme) *).

Inductive program_type : Type :=  (*r Program type *)
 | pt_Single (p:processid) (phi:effect) (C:constraints)
 | pt_Parallell (Phi:program_type) (Phi':program_type).
(** definitions *)

(* defns ContextLookup *)
Inductive ContextLookup : context -> variable -> scheme -> Prop :=    (* defn ContextLookup *)
 | LookupAx : forall (G:context) (x:variable) (SC:scheme),
     ContextLookup  (G_Extend G x SC)  x SC
 | LookupNext : forall (G:context) (x':variable) (SC':scheme) (x:variable) (SC:scheme),
       ( x  <>  x' )   ->
     ContextLookup G x SC ->
     ContextLookup  (G_Extend G x' SC')  x SC.

Definition eq_le_var := Pos.eq_dec.


(** definitions *)

(** funs DownAT *)
Fixpoint downAT (x1:annotatedtype) : simpletype:=
  match x1 with
  | at_Bool => st_Bool
  | at_Thread => st_Thread
  | (at_Lock r) => st_Lock
  | (at_Arrow AT1 phi AT2) => (st_Arrow   (downAT AT1 )     (downAT AT2 )  )
end.

(** definitions *)

(** funs DownSC *)
Fixpoint downSC (x1:scheme) : simpletype:=
  match x1 with
  | (sc_Quant rho_list X_list C AT) =>  (downAT AT ) 
end.



