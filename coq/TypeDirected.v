(* generated by Ott 0.21.2 from: ott/Syntax.ott ott/Common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import ott_list_core.


Require Import Syntax.
Require Import TypeSyntax.
Require Import TypeSpec.
Require Import Substitution.
Require Import FreeVar.
Require Import Constraint.

(** definitions *)

(* defns SyntaxDirected *)
Inductive syntaxdirected : constraints -> context -> expr -> annotatedtype -> effect -> Prop :=    (* defn syntaxdirected *)
 | TD_Var : forall (r_list:list lockset) (D_list:list lockenv) (X_list:list le_var) (rho_list:list ls_var) (C:constraints) (G:context) (x:variable) (th:subst) (AT:annotatedtype) (D:lockenv) (C':constraints),
     ContextLookup G x (sc_Quant rho_list X_list C' AT) ->
       ( th  =   (create_subst  D_list   X_list   r_list   rho_list )  )   ->
       (denote_constraints  C  ->
                                       denote_constraints   (lift_subst_C  th   C' )  )   ->
     syntaxdirected C G (e_Thread (t_Value (v_VarRef x)))  (lift_subst_AT  th   AT )  (EffectIntro D D)
 | TD_NewL : forall (C:constraints) (G:context) (pi:programpoint) (rho:ls_var) (D:lockenv),
       (denote_constraints  C  ->
                                       denote_constraints (cons (c_LockSet  (ls_Single pi)   (ls_Var rho) )  nil))   ->
     syntaxdirected C G (e_NewL pi) (at_Lock (ls_Var rho)) (EffectIntro D D)
 | TD_LRef : forall (C:constraints) (G:context) (l:lockref) (rho rho':ls_var) (D:lockenv),
       (denote_constraints  C  ->
                                       denote_constraints (cons (c_LockSet  (ls_Var rho)   (ls_Var rho') )  nil))   ->
     syntaxdirected C G (e_Thread (t_Value (v_LockRef l (ls_Var rho)))) (at_Lock (ls_Var rho')) (EffectIntro D D)
 | TD_Abs1 : forall (C:constraints) (G:context) (x:variable) (ST:simpletype) (t:thread) (AT1:annotatedtype) (phi:effect) (AT2:annotatedtype) (D:lockenv) (ST1:simpletype),
       (  (downAT AT1 )   =  ST1 )   ->
     syntaxdirected C (G_Extend G x  (sc_Quant nil nil nil  AT1 ) ) (e_Thread t) AT2 phi ->
     syntaxdirected C G (e_Thread (t_Value (v_Fun x ST t))) (at_Arrow AT1 phi AT2) (EffectIntro D D)
 | TD_Abs2 : forall (C:constraints) (G:context) (f:variable) (ST1 ST2:simpletype) (x:variable) (t:thread) (AT1:annotatedtype) (phi:effect) (AT2:annotatedtype) (D1 D2:lockenv),
       (  (downAT AT1 )   =  ST1 )   ->
       (  (downAT AT2 )   =  ST2 )   ->
     syntaxdirected C (G_Extend (G_Extend G f  (sc_Quant nil nil nil  (at_Arrow AT1 phi AT2) ) ) x  (sc_Quant nil nil nil  AT2 ) ) (e_Thread t) AT2 phi ->
       ( phi  =  (EffectIntro D1 D2) )   ->
     syntaxdirected C G (e_Thread (t_Value (v_RecFun f (st_Arrow ST1 ST2) x ST1 t))) (at_Arrow AT1 phi AT2) (EffectIntro D1 D1)
 | TD_App : forall (C:constraints) (G:context) (v1 v2:value) (AT1:annotatedtype) (D D':lockenv) (AT2:annotatedtype) (D1 D2:lockenv),
     syntaxdirected C G (e_Thread (t_Value v1)) (at_Arrow AT2 (EffectIntro D1 D2) AT2) (EffectIntro D D) ->
     syntaxdirected C G (e_Thread (t_Value v2)) AT2 (EffectIntro D D) ->
     syntaxdirected C G (e_App v1 v2) AT1 (EffectIntro D D')
 | TD_Cond : forall (C:constraints) (G:context) (v:value) (e1 e2:expr) (AT:annotatedtype) (D D':lockenv) (AT1 AT2:annotatedtype) (D1 D2:lockenv),
     subtype C AT1 AT ->
     subtype C AT2 AT ->
     abstrstate_order C D1 D' ->
     abstrstate_order C D2 D' ->
     syntaxdirected C G (e_Thread (t_Value v)) at_Bool (EffectIntro D D) ->
     syntaxdirected C G e1 AT1 (EffectIntro D D1) ->
     syntaxdirected C G e2 AT2 (EffectIntro D D2) ->
     syntaxdirected C G (e_Cond v e1 e2) AT (EffectIntro D D')
 | TD_Let : forall (X_list:list le_var) (rho_list:list ls_var) (C2:constraints) (G:context) (x:variable) (ST1:simpletype) (e:expr) (t:thread) (AT2:annotatedtype) (D1 D3:lockenv) (C1:constraints) (AT1:annotatedtype) (D2:lockenv) (C:constraints) (e2:expr),
     syntaxdirected  ( C1  ++  C2 )  G e AT1 (EffectIntro D1 D2) ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_ls_G  G )  )
                                               rho_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_ls_C  C )  )
                                               rho_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_le_G  G )  )
                                               X_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_le_C  C )  )
                                               X_list )   ->
     syntaxdirected C2 (G_Extend G x (sc_Quant rho_list X_list C1 AT1)) e2 AT2 (EffectIntro D2 D3) ->
     syntaxdirected C2 G (e_Thread (t_Let x ST1 e t)) AT2 (EffectIntro D1 D3)
 | TD_Spawn : forall (C:constraints) (G:context) (t:thread) (D1:lockenv) (AT:annotatedtype) (D2:lockenv),
     syntaxdirected C G (e_Thread t) AT (EffectIntro le_Empty D2) ->
     syntaxdirected C G (e_Spawn t) at_Thread (EffectIntro D1 D1)
 | TD_Lock : forall (C:constraints) (G:context) (v:value) (rho:ls_var) (D1 D2:lockenv),
     syntaxdirected C G (e_Thread (t_Value v)) (at_Lock (ls_Var rho)) (EffectIntro D1 D1) ->
     abstrstate_order C (le_Add D1  (le_Append le_Empty  (ls_Var rho)  (Zinf_Z 1)) ) D2 ->
     syntaxdirected C G (e_AcqLock v) (at_Lock (ls_Var rho)) (EffectIntro D1 D2)
 | TD_Unlock : forall (C:constraints) (G:context) (v:value) (rho:ls_var) (D1 D2:lockenv),
     syntaxdirected C G (e_Thread (t_Value v)) (at_Lock (ls_Var rho)) (EffectIntro D1 D1) ->
     abstrstate_order C (le_Sub D1  (le_Append le_Empty  (ls_Var rho)  (Zinf_Z 1)) ) D2 ->
     syntaxdirected C G (e_RelLock v) (at_Lock (ls_Var rho)) (EffectIntro D1 D2).


