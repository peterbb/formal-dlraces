(* generated by Ott 0.21.2 from: ott/Syntax.ott ott/Common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import ott_list_core.


Require Export ZArith.

Require Export Syntax.
Require Export TypeSyntax.
Require Import Substitution.
Require Import FreeVar.
Require Import Constraint.

(** definitions *)

(* defns AbstrSateOrder *)
Inductive abstrstate_order : constraints -> lockenv -> lockenv -> Prop :=    (* defn abstrstate_order *)
 | SO_Refl : forall (C:constraints) (D:lockenv),
     abstrstate_order C D D
 | SO_Trans : forall (C:constraints) (D1 D3 D2:lockenv),
     abstrstate_order C D1 D2 ->
     abstrstate_order C D2 D3 ->
     abstrstate_order C D1 D3
 | SO_Ax : forall (D D':lockenv),
     abstrstate_order  (cons  (c_LockEnv D D')  nil)  D D'
 | SO_Base : forall (C:constraints) (D1 D2:lockenv),
       (pointwise_leq  D1   D2 )   ->
     abstrstate_order C D1 D2
 | SO_Plus1 : forall (C:constraints) (D2 D1:lockenv),
     abstrstate_order C le_Empty D1 ->
     abstrstate_order C D2 (le_Add D2 D1)
 | SO_Plus2 : forall (C:constraints) (D2 D1:lockenv),
     abstrstate_order C D1 le_Empty ->
     abstrstate_order C (le_Add D2 D1) D2
 | SO_Minus1 : forall (C:constraints) (D2 D1:lockenv),
     abstrstate_order C le_Empty D1 ->
     abstrstate_order C (le_Sub D2 D1) D2
 | SO_Minus2 : forall (C:constraints) (D2 D1:lockenv),
     abstrstate_order C D1 le_Empty ->
     abstrstate_order C D2 (le_Sub D2 D1).
(** definitions *)

(* defns SubType *)
Inductive subtype : constraints -> annotatedtype -> annotatedtype -> Prop :=    (* defn subtype *)
 | S_Refl : forall (C:constraints) (AT:annotatedtype),
     subtype C AT AT
 | S_Trans : forall (C:constraints) (AT1 AT3 AT2:annotatedtype),
     subtype C AT1 AT2 ->
     subtype C AT2 AT3 ->
     subtype C AT1 AT3
 | S_Lock : forall (C:constraints) (r1 r2:lockset),
       (denote_constraints  C  ->
                                       denote_constraints   (cons  (c_LockSet r1 r2)  nil)  )   ->
     subtype C (at_Lock r1) (at_Lock r2)
 | S_Arrow : forall (C:constraints) (AT1:annotatedtype) (D1 D2:lockenv) (AT2 AT1':annotatedtype) (D1' D2':lockenv) (AT2':annotatedtype),
     subtype C AT1' AT1 ->
     subtype C AT2 AT2' ->
     abstrstate_order C D1' D1 ->
     abstrstate_order C D2 D2' ->
     subtype C (at_Arrow AT1 (EffectIntro D1 D2) AT2) (at_Arrow AT1' (EffectIntro D1' D2') AT2').
(** definitions *)

(* defns TypeAndEffect *)
Inductive welltyped_spec : constraints -> context -> expr -> scheme -> effect -> Prop :=    (* defn welltyped_spec *)
 | T_Var : forall (C:constraints) (G:context) (x:variable) (SC:scheme) (D:lockenv),
     ContextLookup G x SC ->
     welltyped_spec C G (e_Thread (t_Value (v_VarRef x))) SC (EffectIntro D D)
 | T_NewL : forall (C:constraints) (G:context) (pi:programpoint) (rho:ls_var) (D:lockenv),
       (denote_constraints  C  ->
                                       denote_constraints (cons (c_LockSet  (ls_Single pi)   (ls_Var rho) )  nil))   ->
     welltyped_spec C G (e_NewL pi)  (sc_Quant nil nil nil  (at_Lock (ls_Var rho)) )  (EffectIntro D D)
 | T_LRef : forall (C:constraints) (G:context) (l:lockref) (rho rho':ls_var) (D:lockenv),
       (denote_constraints  C  ->
                                       denote_constraints (cons (c_LockSet  (ls_Var rho)   (ls_Var rho') )  nil))   ->
     welltyped_spec C G (e_Thread (t_Value (v_LockRef l (ls_Var rho))))  (sc_Quant nil nil nil  (at_Lock (ls_Var rho')) )  (EffectIntro D D)
 | T_Abs1 : forall (C:constraints) (G:context) (x:variable) (ST1:simpletype) (t:thread) (AT1:annotatedtype) (phi:effect) (AT2:annotatedtype) (D:lockenv),
       (  (downAT AT1 )   =  ST1 )   ->
     welltyped_spec C (G_Extend G x  (sc_Quant nil nil nil  AT1 ) ) (e_Thread t)  (sc_Quant nil nil nil  AT2 )  phi ->
     welltyped_spec C G (e_Thread (t_Value (v_Fun x ST1 t)))  (sc_Quant nil nil nil  (at_Arrow AT1 phi AT2) )  (EffectIntro D D)
 | T_Abs2 : forall (C:constraints) (G:context) (f:variable) (ST1 ST2:simpletype) (x:variable) (t:thread) (AT1:annotatedtype) (D1 D2:lockenv) (AT2:annotatedtype) (phi:effect),
       (  (downAT AT1 )   =  ST1 )   ->
       (  (downAT AT2 )   =  ST2 )   ->
     welltyped_spec C (G_Extend (G_Extend G f  (sc_Quant nil nil nil  (at_Arrow AT1 phi AT2) ) ) x  (sc_Quant nil nil nil  AT1 ) ) (e_Thread t)  (sc_Quant nil nil nil  AT2 )  (EffectIntro D1 D2) ->
     welltyped_spec C G (e_Thread (t_Value (v_RecFun f (st_Arrow ST1 ST2) x ST1 t)))  (sc_Quant nil nil nil  (at_Arrow AT1 (EffectIntro D1 D2) AT2) )  (EffectIntro D1 D1)
 | T_App : forall (C:constraints) (G:context) (v1 v2:value) (AT1:annotatedtype) (D1 D2:lockenv) (AT2:annotatedtype),
     welltyped_spec C G (e_Thread (t_Value v1))  (sc_Quant nil nil nil  (at_Arrow AT2 (EffectIntro D1 D2) AT1) )  (EffectIntro D1 D1) ->
     welltyped_spec C G (e_Thread (t_Value v2))  (sc_Quant nil nil nil  AT2 )  (EffectIntro D1 D1) ->
     welltyped_spec C G (e_App v1 v2)  (sc_Quant nil nil nil  AT1 )  (EffectIntro D1 D2)
 | T_Cond : forall (C:constraints) (G:context) (v:value) (e1 e2:expr) (AT:annotatedtype) (D1 D2:lockenv),
     welltyped_spec C G (e_Thread (t_Value v))  (sc_Quant nil nil nil  at_Bool )  (EffectIntro D1 D1) ->
     welltyped_spec C G e1  (sc_Quant nil nil nil  AT )  (EffectIntro D1 D2) ->
     welltyped_spec C G e2  (sc_Quant nil nil nil  AT )  (EffectIntro D1 D2) ->
     welltyped_spec C G (e_Cond v e1 e2)  (sc_Quant nil nil nil  AT )  (EffectIntro D1 D2)
 | T_Let : forall (C:constraints) (G:context) (x:variable) (ST1:simpletype) (e1:expr) (t2:thread) (AT2:annotatedtype) (D1 D3:lockenv) (SC1:scheme) (D2:lockenv),
     welltyped_spec C G e1 SC1 (EffectIntro D1 D2) ->
       (  (downSC SC1 )   =  ST1 )   ->
     welltyped_spec C (G_Extend G x SC1) (e_Thread t2)  (sc_Quant nil nil nil  AT2 )  (EffectIntro D2 D3) ->
     welltyped_spec C G (e_Thread (t_Let x ST1 e1 t2))  (sc_Quant nil nil nil  AT2 )  (EffectIntro D1 D3)
 | T_Spawn : forall (C:constraints) (G:context) (t:thread) (D1:lockenv) (AT:annotatedtype) (D2:lockenv),
     welltyped_spec C G (e_Thread t)  (sc_Quant nil nil nil  AT )  (EffectIntro le_Empty D2) ->
     welltyped_spec C G (e_Spawn t)  (sc_Quant nil nil nil  at_Thread )  (EffectIntro D1 D1)
 | T_Lock : forall (C:constraints) (G:context) (v:value) (rho:ls_var) (D1 D2:lockenv),
     welltyped_spec C G (e_Thread (t_Value v))  (sc_Quant nil nil nil  (at_Lock (ls_Var rho)) )  (EffectIntro D1 D1) ->
     abstrstate_order C (le_Add D1  (le_Append le_Empty  (ls_Var rho)  (Zinf_Z 1)) ) D2 ->
     welltyped_spec C G (e_AcqLock v)  (sc_Quant nil nil nil  (at_Lock (ls_Var rho)) )  (EffectIntro D1 D2)
 | T_Unlock : forall (C:constraints) (G:context) (v:value) (rho:ls_var) (D1 D2:lockenv),
     welltyped_spec C G (e_Thread (t_Value v))  (sc_Quant nil nil nil  (at_Lock (ls_Var rho)) )  (EffectIntro D1 D1) ->
     abstrstate_order C (le_Sub D1  (le_Append le_Empty  (ls_Var rho)  (Zinf_Z 1)) ) D2 ->
     welltyped_spec C G (e_RelLock v)  (sc_Quant nil nil nil  (at_Lock (ls_Var rho)) )  (EffectIntro D1 D2)
 | T_Gen : forall (X_list:list le_var) (rho_list:list ls_var) (C1:constraints) (G:context) (e:expr) (C2:constraints) (AT:annotatedtype) (D1 D2:lockenv),
     welltyped_spec  ( C1  ++  C2 )  G e  (sc_Quant nil nil nil  AT )  (EffectIntro D1 D2) ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_ls_G  G )  )
                                               rho_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_le_G  G )  )
                                               X_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_ls_C  C1 )  )
                                               rho_list )   ->
       (Forall 
                                              (fun x => ~PositiveSet.In x   (free_le_C  C1 )  )
                                               X_list )   ->
     welltyped_spec C1 G e (sc_Quant rho_list X_list C2 AT) (EffectIntro D1 D2)
 | T_Inst : forall (r_list:list lockset) (D_list:list lockenv) (X_list:list le_var) (rho_list:list ls_var) (UNK: NUM 1 UNK: NUM 2:UNK_CTP) (C1:constraints) (G:context) (e:expr) (th:subst) (AT:annotatedtype) (C2:constraints) (t101 t102 t103 t104:lockenv),
          nth_error D_list (2 - 1) = Some t101 ->
     nth_error D_list (1 - 1) = Some t102 ->
     nth_error D_list (2 - 1) = Some t103 ->
     nth_error D_list (1 - 1) = Some t104 ->
welltyped_spec C1 G e (sc_Quant rho_list X_list C2 AT) (EffectIntro t102 t101) ->
       ( th  =   (create_subst  D_list   X_list   r_list   rho_list )  )   ->
       (denote_constraints  C1  ->
                                       denote_constraints   (lift_subst_C  th   C2 )  )   ->
     welltyped_spec C1 G e  (sc_Quant nil nil nil   (lift_subst_AT  th   AT )  )  (EffectIntro t104 t103)
 | T_Sub : forall (C:constraints) (G:context) (e:expr) (AT1:annotatedtype) (D1' D2':lockenv) (AT2:annotatedtype) (D1 D2:lockenv),
     welltyped_spec C G e  (sc_Quant nil nil nil  AT2 )  (EffectIntro D1 D2) ->
     subtype C AT2 AT1 ->
     abstrstate_order C D1' D1 ->
     abstrstate_order C D2 D2' ->
     welltyped_spec C G e  (sc_Quant nil nil nil  AT1 )  (EffectIntro D1' D2')
with welltyped_prog_spec : program -> program_type -> Prop :=    (* defn welltyped_prog_spec *)
 | T_Thread : forall (p:processid) (t:thread) (phi:effect) (C:constraints) (AT:annotatedtype),
     welltyped_spec C G_Empty (e_Thread t)  (sc_Quant nil nil nil  AT )  phi ->
     welltyped_prog_spec (P_Single p t) (pt_Single p phi C)
 | T_Par : forall (P1 P2:program) (Phi1 Phi2:program_type),
     welltyped_prog_spec P1 Phi1 ->
     welltyped_prog_spec P2 Phi2 ->
     welltyped_prog_spec (P_Parallel P1 P2) (pt_Parallell Phi1 Phi2).


